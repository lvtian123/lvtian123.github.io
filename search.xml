<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程--生产者,消费者模式]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F23%2F%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[生产者和消费者问题引入1：生产者和消费者问题的产生; 2：Object类对多线程的支持; 代码实现public class Relationship { public static void main(String[] args) { Info info=new Info(); new Thread(new Customer(info)).start(); new Thread(new Productor(info)).start(); } } class Info{ private String title; private String content; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } class Productor implements java.lang.Runnable {//生产者 private Info info; public Productor(Info info){ this.info=info; } @Override public void run() { for(int x=0;x&lt;100;x++){ if(x%2==0){ this.info.setTitle("左"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } this.info.setContent("右"); }else { this.info.setTitle("上"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } this.info.setContent("下"); } } } } class Customer implements java.lang.Runnable {//消费者 private Info info; public Customer(Info info){ this.info=info; } @Override public void run() { for(int x=0;x&lt;200;x++){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(this.info.getTitle()+"--"+this.info.getContent()); } } } 发现问题：1：取的数据错位 2：取的数据重复 解决重复问题--加入等待与唤醒机制，在Object类里面提供有专门的处理方法 |--等待:public final native void wait(long var1) throws InterruptedException; |--唤醒第一个等待线程:public final native void notify(); |--唤醒全部等待线程:public final native void notifyAll();]]></content>
  </entry>
  <entry>
    <title><![CDATA[类集]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F23%2F%E7%B1%BB%E9%9B%86%2F</url>
    <content type="text"><![CDATA[类集类集:就是java数据结构,动态对象数组的实123456789|--Collection,list,set--|List子接口的操作特点以及常用子类(ArrayList,Vector)public interface List&lt;E&gt; extends Collection&lt;E&gt; public E get(int index);public E set(int index, E element);public ListIterator&lt;E&gt; listIterator(); 12345678910注：List子接口扩充有get方法;List特点: 1,可重复保存数据,顺序为保存的先后顺序; 2,扩充了get()方法; 3,数据异步操作，线程安全; Set接口:hashSet,treeSethashSet:写入的数据无序,不重复;treeSet:有序,不重复;]]></content>
  </entry>
  <entry>
    <title><![CDATA[复习基础反射及代码演示]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F23%2F%E5%A4%8D%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[反射(反射作用:程序真正解耦合，且扩展性强。)一：Class类对象实例化123456789101112java.lang.Class是一个类,这个类是反射操作的源头,即：所有的反射都要从此类开始，这个类有三种实例化方式;|--调用Object类中的getClass()方法;import java.util.Date;public class Reflect &#123; public static void main(String[] args) &#123; Date date=new Date(); /* System.out.println(date.getClass());*/ Class&lt;?&gt; cls= date.getClass(); System.out.println(cls); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859|--使用类.class取得import java.util.Date;public class Reflect &#123;//hibernate/spring/Mybatis public static void main(String[] args) &#123; Class&lt;?&gt; cls= Date.class; System.out.println(cls); &#125;&#125;``` ``` bash|--调用Class类提供的方法//不使用import导入明确的类public class Reflect &#123; //hibernate/spring/Mybatis public static void main(String[] args) throws Exception&#123; Class&lt;?&gt; cls= Class.forName("java.util.Date"); System.out.println(cls); &#125;&#125;``` ### 注释:一切的耦合都起源于new;``` bash代码演示:package com.lv.rr;interface Firut&#123; public void eat();&#125;class Orange implements Firut &#123; @Override public void eat() &#123; System.out.println("吃橘子......."); &#125;&#125;class apple implements Firut &#123; @Override public void eat() &#123; System.out.println("吃苹果......."); &#125;&#125;class Factory&#123; public static Firut getInstance(String className)&#123; Firut f=null; try &#123; f=(Firut) Class.forName(className).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return f; &#125;&#125;public class Reflect &#123; public static void main(String[] args) throws Exception&#123; Firut f= Factory.getInstance("com.lv.rr.apple"); f.eat(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[复习springmvc相应组件]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F23%2F%E5%A4%8D%E4%B9%A0springmvc%E7%9B%B8%E5%BA%94%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[springMvc组件：1：前端控制器DispatcherServlet：作用接收请求，响应结果，相当于转发器有了DisptcherServlet减少了其他组件的耦合度 2：处理器映射器： HandlerMapping （根据请求的url查找Handler）3；处理器适配器：HandlerAdapter（去执行Handler）4；视图解析器 View resolver（进行视图解析，根据逻辑视图解析成真正的视图（view））5；视图view（view是一个接口，实现类支持不同的view类型）springMvc流程一：发送请求到前端控制器(DispatcherServlet)二：前端控制器请求HandlerMapping(处理映射器)查找Handler,可以根据xml配置,注解进行查找;三：HandlerMapping返回Handler;四：前端控制器调用处理器适配器去执行Handler五：处理器适配器去执行Handler六：Handler执行完后返回给适配器ModelAndView七：处理器适配器返回给前端控制器ModelAndView(ModelAndView是springmvc框架的一个底层对象，包括Model和view)八：前端控制器请求视图解析器去进行试图解析，根据逻辑视图名解析成真正的视图(jsp)九：视图解析器向前端控制器返回View十：前端控制器进行视图渲染视图渲染将模型数据(在ModelAndView对象中)填充到request域 十一：前端控制器前用户显示结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[springmvc配置以及执行步骤总结]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F23%2Fspringmvc%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[springmvc配置1：mvc:annotation-driven/ 2：&lt;context:component-scan base-package=””&gt;&lt;!--自动扫描 @Controller--&gt; 3:&lt;!--处理器映射器 :bean的name作为url进行查找 --&gt; 4:&lt;!--处理器适配器 --&gt; 5:&lt;!-- 视图解析器 --&gt; 123456789 ## 通过前端控制器分析springmvc执行步骤 ### 第一步:前端控制器接收请求,调用doDispatch``` bash protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false;｝ 第二步:前端控制器调用处理器映射器查找 Handler 并返回Handler 查找 Handler：mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) { noHandlerFound(processedRequest, response); return; } 返回Handler：protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { for (HandlerMapping hm : this.handlerMappings) { if (logger.isTraceEnabled()) { logger.trace( "Testing handler map [" + hm + "] in DispatcherServlet with name '" + getServletName() + "'"); } HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) { return handler; } } return null; ``` } ### 第三步:调用处理器适配器执行Handler，得到ModelAndView ``` bash mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 第四步:将model填充到request域]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring相关]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F23%2Fspring%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1.Spring中AOP的应用场景、Aop原理、好处？1234567891011121314151617181920答：AOP--Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用:Authentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化 校准、Performance optimization 性能优化、Persistence 持久化、Resource pooling 资源池、Synchronization 同步、Transactions 事务原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。优点：1.各个步骤之间的良好隔离性耦合性大大降低 2.源代码无关性，再扩展功能的同时不对源码进行修改操作 ``` ##2.Spring中IOC的作用与原理？对象创建的过程。``` bash答：IOC--Inversion of Control控制反转。当某个角色需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例对象。但在spring中创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者 直接使用。``` ## 3.介绍spring框架``` bash 它是一个一站式（full-stack全栈式）框架，提供了从表现层-springMVC到业务层-spring再到持久层-springdata的一套完整的解决方案。我们在项目中可以只使用spring一个框架，它就可以提供表现层的mvc框架，持久层的Dao框架。它的两大核心IoC和AOP更是为我们程序解耦和代码简洁易维护提供了支持。``` 4.Spring常见创建对象的注解？``` bash答：@Component@Controller@ Service@ Repository 5.Spring中用到的设计模式123答：简单工厂、工厂方法、单例模式、适配器、包装器、代理、观察者、策略、模板方法详细介绍:请参考本微博的：开发常用设计模式 6.Spring的优点？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354答：1.降低了组件之间的耦合性 ，实现了软件各层之间的解耦 2.可以使用容易提供的众多服务，如事务管理，消息服务等 3.容器提供单例模式支持 4.容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 5.容器提供了众多的辅助类，能加快应用的开发 6.spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts等 7.spring属于低侵入式设计，代码的污染极低 8.独立于各种应用服务器 9.spring的DI机制降低了业务对象替换的复杂性 10.Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring 的部分或全部 ``` ## 7.Spring Bean的作用域之间有什么区别？``` bashSpring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。``` ## 8.Spring管理事务有几种方式？``` bash答：有两种方式：1、编程式事务，在代码中硬编码。(不推荐使用)2、声明式事务，在配置文件中配置（推荐使用）声明式事务又分为两种：a、基于XML的声明式事务b、基于注解的声明式事务``` ## 9.spring中自动装配的方式有哪些？``` bash答：1、 No：即不启用自动装配。2、 byName：通过属性的名字的方式查找JavaBean依赖的对象并为其注入。比如说类Computer有个属性printer，指定其autowire属性为byName后，Spring IoC容器会在配置文件中查找id/name属性为printer的bean，然后使用Seter方法为其注入。3、 byType：通过属性的类型查找JavaBean依赖的对象并为其注入。比如类Computer有个属性printer，类型为Printer，那么，指定其autowire属性为byType后，Spring IoC容器会查找Class属性为Printer的bean，使用Seter方法为其注入。4、 constructor：通byType一样，也是通过类型查找依赖对象。与byType的区别在于它不是使用Seter方法注入，而是使用构造子注入。5、 autodetect：在byType和constructor之间自动的选择注入方式。6、 default：由上级标签&lt;beans&gt;的default-autowire属性确定。 10.spring中的核心类有那些，各有什么作用？12345答：BeanFactory：产生一个新的实例，可以实现单例模式BeanWrapper：提供统一的get及set方法ApplicationContext:提供框架的实现，包括BeanFactory的所有功能 11.Bean的调用方式有哪些？123456789101112131415答：有三种方式可以得到Bean并进行调用： 1、使用BeanWrapper HelloWorld hw=new HelloWorld(); BeanWrapper bw=new BeanWrapperImpl(hw); bw.setPropertyvalue(”msg”,”HelloWorld”); system.out.println(bw.getPropertyCalue(”msg”)); 2、使用BeanFactory InputStream is=new FileInputStream(”config.xml”); XmlBeanFactory factory=new XmlBeanFactory(is); HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”); system.out.println(hw.getMsg()); 3、使用ApplicationConttext ApplicationContext actx=new FleSystemXmlApplicationContext(”config.xml”); HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”); System.out.println(hw.getMsg()); 12.什么是IOC，什么又是DI，他们有什么区别？1234567891011121314151617答：依赖注入DI是一个程序设计模式和架构模型， 一些时候也称作控制反转，尽管在技术上来讲，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个 数据库连接已参数的形式传到一个对象的结构方法里面而不是在那个对象内部自行创建一个连接。控制反转和依赖注入的基本思想就是把类的依赖从类内部转化到外 部以减少依赖应用控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所 以，控制反转是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转。``` ## 13.spring有两种代理方式：``` bash答: 若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。 优点：因为有接口，所以使系统更加松耦合 缺点：为每一个目标类创建接口若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。 优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。 缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。 14.springMVC的流程？123456789101112131415161718192021答：1.用户发送请求至前端控制器DispatcherServlet2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5.执行处理器(Controller，也叫后端控制器)。6.Controller执行完成返回ModelAndView7.HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器9.ViewReslover解析后返回具体View10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11.DispatcherServlet响应用户 15.Springmvc的优点123456789答：1.它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成.2.不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)3. 可以任意使用各种视图技术,而不仅仅局限于JSP4 . 支持各种请求资源的映射策略5 .它应是易于扩展的 配置spring和mybatis整合的xml:1；数据源2: sqlSessionFactory3: mapper扫描器]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程的同步与死锁以及代码的实现]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F17%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%AD%BB%E9%94%81%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[线程的同步与死锁一,线程的同步原因1同步：多个线程访问同一资源 二,线程的同步处理操作1java里面想要实现线程同步可以使用synchronized关键字,关键字通过两种方式使用： 一:同步代码块1234567891011121314普通块,构造块,静态块,同步块public void run() &#123; for(int x=0;x&lt;10;x++)&#123; synchronized (this)&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(this.tricet&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"买票ticket"+this.tricet--);&#125; &#125; &#125; &#125; 二:同步方法@Override public void run() { for(int x=0;x&lt;10;x++){ this.sale(); } } public synchronized void sale(){ if(this.tricet&gt;0){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+"买票ticket"+this.tricet--); } } 同步与异步的区别：异步操作速度要高于同步,但同步的安全性高,属于线程安全; 三,线程的死锁情况多个线程访问同一个资源时需要考虑到哪些情况？有可能带来哪些问题？ 1：多个线程访问同一个资源时一定要处理好同步，可以使用同步方法或者同步代码块; |--同步代码块：synchronized(锁定对象){代码} |--同步方法： public synchronized 返回值 方法名(){代码 2；过多的使用同步有可能造成死锁]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程的命名与取得,休眠以及优先级]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F17%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E5%90%8D%E4%B8%8E%E5%8F%96%E5%BE%97-%E4%BC%91%E7%9C%A0%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[线程的命名与取得1234 对线程名称操作,可以使用Thread类的如下方法： 构造方法： public Thread(Runnable target, String name);设置名字： public final void setName(String);取得名字： public final String getName(); 每一个JVM进程启动的时候至少启动几个线程？12main线程：程序的主要执行gc线程：负责垃圾回收 线程的休眠1休眠的方法:public static native void sleep(long millis) throws InterruptedException; 线程的优先级设置优先级： public final void setPriority(int newPriority) 取得优先级： public final int getPriority() 发现设置和取得优先级都使用了int数据类型,对此内容有三种取值： 最高优先级： public final static int MAX_PRIORITY; 中等优先级： public final static int NORM_PRIORITY; 最低优先级： public final static int MIN_PRIORITY; 总结： 一:Thread.currentThread()可以取出当前线程对象; 二:Thread.sleep()主要是休眠,有优先顺序;]]></content>
  </entry>
  <entry>
    <title><![CDATA[两种多线程实现方式的区别(Thread和Runnable)]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F17%2F%E4%B8%A4%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB-Thread%E5%92%8CRunnable%2F</url>
    <content type="text"><![CDATA[两种多线程实现方式的区别(Thread和Runnable)1,Thread类是Runnable接口的子类;Runnable接口解决了Thread单继承的短板； 多个对象访问同一资源，通过Runnable实现 2,Runnable接口实现的多线程更加清楚的描述了数据共享的概念Thread单继承(三个任务给了三个线程)12345678910public class TheadTest &#123; public static void main(String[] args) &#123; TheadDemo mt1= new TheadDemo("一号窗口"); TheadDemo mt2= new TheadDemo("二号窗口"); TheadDemo mt3= new TheadDemo("三号窗口"); mt1.start(); mt2.start(); mt3.start();&#125;&#125; Runnable数据共享(一个任务给了三个线程)1234567891011public class RunableTest &#123; public static void main(String[] args) &#123; RunableDemo mt = new RunableDemo(); Thread t1 = new Thread(mt,"一号窗口"); Thread t2 = new Thread(mt,"二号窗口"); Thread t3 = new Thread(mt,"三号窗口"); t1.start(); t2.start(); t3.start();&#125;&#125; 举例说明继承Thread类的，相当于三个卖票10张的任务分别分给三个窗口，他们各做各的事各卖各的票各完成各的任务，因为MyThread继承Thread类，所以在new MyThread的时候在创建三个对象的同时创建了三个线程；实现RUNNABLE的，相当于是拿出一个卖票10张得任务给三个人去共同完成，new MyThread相当于创建一个任务，然后实例化三个Thread，创建三个线程即安排三个窗口去执行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java线程实现的三种方式以及概念]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F17%2Fjava%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1234567891011java线程是通过java.lang.Thread类来实现的。VM启动时会有一个由主方法(public static void main()&#123;&#125;)所定义的线程;可以通过Thread的实例来创建新的线程;每个线程都是通过某个特定的Thread对象所对应的run()方法来完成其操作,方法run()成为线程体;通过Thread类的start()方法来启动一个线程;java线程实现的三种方式 继承Thread类12345678910111213141516171819202122232425public class Runnable &#123; public static void main(String[] args) &#123; Run r1=new Run("lll"); Run r2=new Run("mmm"); Run r3=new Run("ppp"); r1.start(); r2.start(); r3.start(); &#125; &#125;class Run extends Thread&#123; private String name; public Run(String name)&#123; this.name=name; &#125; @Override public void run() &#123; for(int x=0;x&lt;100;x++)&#123; System.out.println("x:"+x+"name"+this.name); &#125; &#125;&#125; 发现：123456781,在执行此代码的时候，如果没有变化是因为CUP运行快;2,Thread源码里面有个IllegalThreadStateException异常，属于选择性处理异常， 当线程重复启动就会报这个错;3,其中的start0()方法结构类似于java中的抽象方法,使用native声明，会使用到JNI技术: 使用java调用本身操作系统提供的函数; 在不同的操作系统中JVM提供了实现start0()方式;4,通过Thread类的start()方法不仅仅要启动多线程的执行代码,而且根据不同的操作系统完成资源分配;5,多进程会抢占资源，所以不可能一个执行完后，执行另一个; public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } private native void start0(); 通过实现Runnable接口来实现多线程实现Runable接口并没有start()方法,但是在Thread类中定义了public Thread(Runnable target)方法, 接收的是Runnable接口对象 public class Runnable { public static void main(String[] args) { Run r1=new Run("lll"); Run r2=new Run("mmm"); Run r3=new Run("ppp"); new Thread(r1).start();//匿名对象 new Thread(r2).start(); new Thread(r3).start(); } } class Run implements java.lang.Runnable { private String name; public Run(String name){ this.name=name; } @Override public void run() { for(int x=0;x&lt;100;x++){ System.out.println("x:"+x+"name"+this.name); } } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[引用传递,数据表与简单java类的映射]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F16%2F%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92-%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%B8%8E%E7%AE%80%E5%8D%95java%E7%B1%BB%E7%9A%84%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[引用传递：同一块堆内存空间可以被不同的桟内存所指向，同一桟内存可以对不同的堆内存进行修改;12345678910111213141516171819202122232425class Message&#123; private String num="nihao"; public Message(String num)&#123; this.num=num; &#125; public String getNum() &#123; return num; &#125; public void setNum(String num) &#123; this.num = num; &#125;&#125;public class reference &#123; public static void main(String[] args) &#123; Message msg= new Message("hello"); fun(msg);//引用传递 System.out.println(msg.getNum()); &#125; public static void fun(Message temp)&#123; temp.setNum("world"); &#125;&#125; 数据表与简单java类的映射一,实现基本字段转换二,设置并取出数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 class Emp&#123; private int Eid; private String Ename; private Dep dep;//设置外键，一个雇员属于多个部门 private Emp mrg;//一个员工对应的领导； public void setMrg(Emp mrg)&#123; this.mrg=mrg; &#125; public Emp getMrg()&#123; return this.mrg; &#125; public void setDep(Dep dep)&#123; this.dep=dep; &#125; public Dep getDep()&#123; return this.dep; &#125; public Emp(int id ,String Ename)&#123; this.Eid=id; this.Ename=Ename; &#125; public String info()&#123; return "员工编号"+this.Eid+"员工名"+this.Ename; &#125;&#125;class Dep&#123; private int Did; private String Dname; private Emp emps[];//设置外键,一个部门有多个员工 public void setEmps(Emp[] emps)&#123; this.emps=emps; &#125; public Emp[] getEmps()&#123; return this.emps; &#125; public Dep(int Did,String Dname)&#123; this.Did=Did; this.Dname=Dname; &#125; public String info()&#123; return "员工编号"+this.Did+"部门名"+this.Dname; &#125;&#125;public class Mapping &#123; public static void main(String[] args) &#123; /*1,产生各自独立对象*/ Dep dep=new Dep(1,"lll"); Emp ea=new Emp(01,"mmm"); Emp eb=new Emp(02,"nnn"); Emp ec=new Emp(03,"bbb"); /* 2,设置雇员和领导关系*/ ea.setMrg(eb); eb.setMrg(ec); /* 3,设置雇员和部门关系*/ ea.setDep(dep); eb.setDep(dep); ec.setDep(dep); dep.setEmps(new Emp[]&#123;ea,eb,ec&#125;); /* 通过员工找到部门和领导信息*/ System.out.println(ea.getDep().info()); System.out.println(eb.getDep().info()); System.out.println(ec.getDep().info()); System.out.println(eb.getMrg().info()); System.out.println(ea.getMrg().info()); System.out.println("---------------"); /* 通过部门找到每个雇员以及领导的信息*/ System.out.println(dep.info()); for(int x=0;x&lt;dep.getEmps().length;x++)&#123; System.out.println(dep.getEmps()[x].info()); /* System.out.println(dep.getEmps()[x].getMrg().info());*/ if(dep.getEmps()[x].getMrg()!=null)&#123; System.out.println(dep.getEmps()[x].getMrg().info()); &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[对象数组]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F14%2F%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[对象数组(将多个对象统一交给数组管理)定义对象数组动态初始化声明并开辟对象数组：类名称 对象数组名称 [] =new 类名称[长度];分步完成：####### 声明对象数组 ######## 开辟对象数组1234567891011121314151617181920212223242526272829303132333435363738class ArrayDemo&#123; private String id; private double price; public ArrayDemo(String i, double p)&#123; id=i; price=p; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public String info()&#123; return "id:"+id+"price:"+price; &#125;&#125;public class ObjectArr &#123; public static void main(String[] args) &#123; ArrayDemo oa[] = new ArrayDemo[3]; oa[0] = new ArrayDemo("1", 1.0); oa[1] = new ArrayDemo("2", 2.0); oa[2] = new ArrayDemo("3", 3.0); for (int x = 0; x &lt; oa.length; x++) &#123; System.out.println(oa[x].info()); &#125; &#125;&#125; 静态初始化：类名称 对象数组名称[] =new 类名称[]{实例化对象,实例化对象,…}123456789101112131415161718192021222324252627282930313233343536373839class ArrayDemo&#123; private String id; private double price; public ArrayDemo(String i, double p)&#123; id=i; price=p; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public String info()&#123; return "id:"+id+"price:"+price; &#125;&#125;public class ObjectArr &#123; public static void main(String[] args) &#123; ArrayDemo oa[] = new ArrayDemo[]&#123; new ArrayDemo("1", 1.0), new ArrayDemo("2", 2.0), new ArrayDemo("3", 3.0)&#125;; for (int x = 0; x &lt; oa.length; x++) &#123; System.out.println(oa[x].info()); &#125; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组的排序和拷贝]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F14%2F%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[升序排列123456789101112131415161718192021222324public class Sort &#123; public static void main(String[] args) &#123; int date []=new int []&#123;1,3,2,6,5,8,4,9,7&#125;; Ssort(date); print(date); &#125; public static void Ssort(int arr[])&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr.length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int pl=arr[j]; arr[j]=arr[j+1]; arr[j+1]=pl; &#125; &#125; &#125; &#125; public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125; 前后转置(一维数组)1234567891011121314151617181920212223242526272829public class ChangTwo &#123; public static void main(String[] args) &#123; int date[]=new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; sort(date); print(date); &#125; public static void sort(int arr[])&#123; int len=arr.length/2; int head=0; int foot=arr.length-1; for(int x=0;x&lt;len;x++)&#123; int temp=arr[head]; arr[head]=arr[foot]; arr[foot]=temp; head++; foot--; &#125; &#125; public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125; 数组的操作方法数组的拷贝：将一个数组的部分内容拷贝到另一个数组当中;12345678910111213141516public class ArrayCopy &#123; public static void main(String[] args) &#123; int dateA[]=new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; int dateB[]=new int[]&#123;11,12,13,14,15,46,17,18,19&#125;; System.arraycopy(dateA,4,dateB,4,3);//(源数组,开始索引，目标数组，开始索引，索引长度),拷贝并替换; print(dateB); &#125; public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125; 数组排序12345678910111213141516171819202122232425public class Sort &#123; public static void main(String[] args) &#123; int date []=new int []&#123;1,3,2,6,5,8,4,9,7&#125;; /*Ssort(date);*/ Arrays.sort(date); print(date); &#125; /*public static void Ssort(int arr[])&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr.length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int pl=arr[j]; arr[j]=arr[j+1]; arr[j+1]=pl; &#125; &#125; &#125; &#125;*/ public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[封装型,构造函数,以及匿名对象的使用]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F13%2F%E5%B0%81%E8%A3%85%E5%9E%8B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E4%BB%A5%E5%8F%8A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一:封装性1,所有类当中定义的属性都必须使用private声明，如果被外部类引用，定义相应的setter,getter方法；2，封装性就是类内部定义的属性对外部不可见;二:构造方法的基本语法及调用时机1,构造方法：类名与方法名相同，无返回值声明;2,构造方式实在类对象被实例化(new)之后默认被调用的;3,一个类中至少保留一个构造方法;4,构造方式是在对象被实例化之后：只能调用一次; 普通方法是在对象被实例化之后：多次调用;（说白了就是构造方法的重载）1234567891011121314151617181920212223242526272829303132333435363738394041424344### 5,构造方法的核心作用:在类对象实例化的时候，设置属性的初始化内容; User user =new User();//类对象实例化 public User(String name;String age)&#123; this.name=name; this.age=age; &#125;//设置属性的初始化内容public class Structure &#123; public static void main(String[] args) &#123; Boook bk= null; bk = new Boook();//构造方法只有在声明并实例化之后，才会被引用；22 System.out.println(bk);//成为垃圾了(内存) bk=new Boook();//bk改变成为新的引用，之前的22成为垃圾(内存) System.out.println(bk); bk.info();//多次调用 bk.info(); bk.info(); &#125;&#125;class Boook&#123; private String id; private double price; public void info()&#123; System.out.println("********")&#125; public Boook()&#123; System.out.println(".........."); &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125;&#125; 6,匿名对象在重载时，要求至改变参数的类型和个数;三:匿名对象的基本使用123456781，匿名对象由于没有其它对象对其进行引用，所以只能使用一次，然后成为垃圾(内存)； public static void main(String[] args) &#123; /*Book bk = new Book("hello",1.0); bk.info();*/ new Book("hello",1.0).info();//匿名对象的使用,且无法被引用。 &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[递归，类和对象，堆内存和桟内存]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F12%2F%E9%80%92%E5%BD%92%EF%BC%8C%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A1%9F%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[一:递归12345678910111213141516171,递归必须发生在方法中;2,递归必须有规定条件，不然就像耕地一样，耕死了。例子：public class recursive &#123; public static void main(String[] args) &#123; System.out.println(sum(100)); System.out.println(sum(200)); &#125; public static int sum(int num)&#123; if(num==1)&#123; return 1; &#125; return num+sum(num-1); &#125;&#125; 二:类与对象12345678910111,类与对象是整个面向对象之中最为基础的组成元素,(类是共性的集合，对象是某个性的产物。)2,类是描述对象的结构想要使用类必须要有对象，对象的定义方式：1：声明并实例化：User user = new User(); 2: 分步完成：User user=null; user=new User();引用数据类型与基本数据类型的不同在于需要的内存的开辟及使用，所以new的主要功能就是开辟内存空间； 首字母大写的都是类名称，类名称都是引用类型，应用类型的默认值都是空; 三:堆内存和桟内存123456789堆内存：只有在new一个对象的时候，才会开辟一个堆内存（实例化对象）桟内存：存放堆内存的地址(一个桟内存只能指定一个堆内存，一个堆内存可以被多个桟内存指定)产生的垃圾会被垃圾收集器CG回收引用传递: Book b=null; Book a=new Book(); a.id="1"; a.price=2.0; b=a;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Our love is too helpless]]></title>
    <url>lvtian123.github.io%2F2018%2F06%2F13%2FOur-love-is-too-helpless%2F</url>
    <content type="text"><![CDATA[Yes,i’m during a Phase transformation,Before two days, i break up with my girlfriends who get along with me about three years,Here i will review some experience about three years,it’s realized a conclusion for me,----------------------2015.9.13------------------- this day, i enter a university what be expected by family,everthing is just beginning,andtry New things. So, i join the Student union where to give me love,we know each other in there.i deeply love this girl where in front of my eyes,i beginning chat with her until midnight,she enjoyed.So,i think it’s a good time that i can make an appointment ,We met on theporch bridge behind the school. We talked about our ideal life and the university.In the first place. When I asked her if she was thinking about dating in college, sherefused.And I don’t give up, on my offensive.She gradually recognized me and gave me a two-week test period, which was actuallyonly one week. ---------------------2015.10.11------------------- This day I want to kiss her, by her clever dodge away, the old face dark red, angryand ashamed of me in the space to say disdain oneself ---------------------2018.6.11-------------------- That day, at the end of our junior year, we ended up arguing.On second thought, in this relationship, we all pay a lot and love each other deeply.We try to accommodate each other, but,The quarrel has never let the fire out, so I choseto give up, although I still love deeply, but at this time a kind of torture to the soul.only Letting each other go? Love is for mutual comfort. After that, I only remember that there was a quarrel. Yes, there was an endless quarrel. Please cherish each other’s feelings]]></content>
  </entry>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>lvtian123.github.io%2F2018%2F06%2F05%2F%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[CREATE TABLE tea (tid INT ( 10 ) NOT NULL PRIMARY KEY AUTO_INCREMENT,tname VARCHAR(20),tphonum VARCHAR(20)) CREATE TABLE course(cid int (20) not null PRIMARY KEY auto_increment,cname VARCHAR(20) not null) CREATE TABLE xuanke( sid int (10),tid int (10),cid int (10),xuefen int (20) ) SELECT * FROM tea; 1-- 使用on 句子 SELECT s.sname,t.tname,c.cname,x.xuefen from stu s join xuanke x on s.sid = x.sid join tea t on t.tid = x.tid join course c on c.cid = x.cid ; 1-- 使用using句子 SELECT s.sname,t.tname,c.cname,x.xuefen from stu s join xuanke x using(sid) join tea t using(tid) join course c using(cid) ; 1-- left/right join 以及过滤条件 where ,and SELECT s.sname , x.xuefen FROM stu s right join xuanke x using(sid) where sname=”ll”; 1-- 笛卡尔积 select * from stu,tea,course,xuanke; select * from stu CROSS JOIN tea;]]></content>
  </entry>
  <entry>
    <title><![CDATA[shiro安全以及md5加密学习]]></title>
    <url>lvtian123.github.io%2F2018%2F06%2F01%2Fshiro%E5%AE%89%E5%85%A8%E4%BB%A5%E5%8F%8Amd5%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1## 2018.5.31 学习shiro– shiro session管理– shiro 缓存管理– shiro 集成Spring 什么是shiro–Apache的强大灵活开源安全框架 –认证，授权，企业会话管理，安全加密 shiro与sping securityshiro : 简单，灵活， 可脱离spring 粒度较粗 sping security ： 复杂，笨重 不可脱离spring 粒度较细(粒度：个人认为就是管理事务的程度，每条河如果是粒度较细，汇聚成大海，那么大海就是粒度较粗) shrio整体架构：Authenticator: 认证器（管理登录和退出）---&gt;通过Realms获取认证信息 ，做对比 Authorizer: 授权器 （subject有哪些权限）---&gt;通过Realms获取认证信息 ，做对比 Session Manager Session Dao Cache Manager(缓存管理器) Pluggable Realms数据库，数据源之间的桥梁 Cryptography:加密 Shiro认证创建SecurityManager–&gt;主体提交认证（Subject）–&gt;SecurityManager认证–&gt;Authenticator认证–&gt;Realm验证 Shiro自定义Realm 以及 自定义RealmIniRealm jdbcRealm ；设置权限数据默认为false; jdbcRealm.setPermissionsLookupEnabled(true); 1## 2018.6.1 Shiro加密shiro散列配置 : HashedCredentialsMatcher 自定义Realm中使用散列 盐的使用 （使用md5加密） 学习redis nosql 数据存储的瓶颈1.数据量的总大小，一个机器放不下时2.数据的索引（b+tree）一个机器的内存放不下时3.访问量（读写混合）一个实例不能承受 Memcached缓存缓解数据库压力]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单的ssm框架设计]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F30%2F%E7%AE%80%E5%8D%95%E7%9A%84ssm%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1## 2018.5.20 1；ssm2; mysql3; bootstrap4; maven5; 分页pagehelper6; 逆向工程 Mybatis Generator 环境搭建1；maven2；bootstrap 1## 2018.5.29 springBoot底层使用slf4j+logback的方式进行日志记录 1## 2018.5.30 模版引擎：thymeleaf]]></content>
  </entry>
  <entry>
    <title><![CDATA[123]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F09%2F123%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[第一次使用idea，用maven管理springboot+swagger集成，实现对数据库(mysql)的CRUD]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F04%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8idea%EF%BC%8C%E7%94%A8maven%E7%AE%A1%E7%90%86springboot-swagger%E9%9B%86%E6%88%90%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93-mysql-%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[一；创建maven管理的springboot工程（此步骤忽略）二：配置pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;SpringBootLearning&lt;/groupId&gt; &lt;artifactId&gt;SpringBootLearning&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--添加swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Mysql和JPA--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 三：配置application.properties(此处为我的数据库)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 server.port=8080 spring.datasource.url = jdbc:mysql://localhost:3306/people spring.datasource.username = root spring.datasource.password = 123456 spring.datasource.driverClassName = com.mysql.jdbc.Driver # Specify the DBMS spring.jpa.database = MYSQL # Show or not log for each sql query spring.jpa.show-sql = true # Hibernate ddl auto (create, create-drop, update) spring.jpa.hibernate.ddl-auto = update``` ## 四：java层面（bean,dao,controller）以及同等级的Swagger2Configure### 1；bean``` bash package com.lv.bean; import javax.persistence.*; @Entity @Table(name = "user") public class User &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private int age; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 2.Dao123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163 package com.lv.dao; import com.lv.bean.User; import org.springframework.data.repository.CrudRepository; public interface UserDao extends CrudRepository&lt;User, Long&gt; &#123; public User findById(Long id); public User findByName(String name); &#125; （为什么我只写了两个方法呢？因为CrudRepository已经包含了我们所需要的其它方法） ``` ### 3.controller``` bash package com.lv.controller; import com.lv.dao.UserDao; import com.lv.bean.User; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController @RequestMapping(value = "/user") @Api(description = "UserController") public class UserController &#123; @Resource UserDao userDAO; @ApiOperation(value = "添加用户") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "name" , value = "name" , paramType = "query" , required = true ), @ApiImplicitParam(name = "age" , value = "age" , paramType = "query" , required = true ) &#125;) @RequestMapping(value = "/addUser" , method = RequestMethod.POST) public String addUser(@RequestParam(value = "name") String name,@RequestParam(value = "age") int age)&#123; User user = new User(); user.setName(name); user.setAge(age); userDAO.save(user); return "add user success !"; &#125; @ApiOperation(value="按姓名查找") @ApiImplicitParam(name = "name",value = "name", paramType = "query",required = true,dataType = "string") @RequestMapping(value ="/findByName",method = RequestMethod.POST) public String findByName(@RequestParam(value= "name") String name)&#123; User user =userDAO.findByName(name); if(user == null)&#123; return "error"; &#125;else&#123; return "id:"+user.getId()+",name:" + user.getName() + " , age:" + user.getAge(); &#125; &#125; @ApiOperation(value = "查找用户") @ApiImplicitParam(name = "id" , value = "id" , paramType = "query" , required = true , dataType = "int") @RequestMapping(value = "/findById" , method = RequestMethod.POST) public String findById(@RequestParam(value = "id") Long id)&#123; User user = userDAO.findById(id); if(user == null)&#123; return "error"; &#125;else&#123; return "name:" + user.getName() + " , age:" + user.getAge(); &#125; &#125; @ApiOperation(value = "查询所有用户") @RequestMapping(value = "/findAll" , method = RequestMethod.POST) public Iterable findAll()&#123; Iterable&lt;User&gt; userList = userDAO.findAll(); return userList; &#125; @ApiOperation(value ="删除所有用户") @RequestMapping(value="/deleteAll",method = RequestMethod.POST) public String deleteAll()&#123; userDAO.deleteAll(); return "delete success!"; &#125; @ApiOperation(value = "删除用户") @ApiImplicitParam(name = "id" , value = "id" , paramType = "query" , required = true , dataType = "int") @RequestMapping(value = "/deleteById" , method = RequestMethod.POST) public String deleteById(@RequestParam(value = "id") Long id)&#123; userDAO.delete(id); return "delete success !"; &#125; &#125; ``` ### 4.Swagger2Configure``` bash package com.lv; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class Swagger2Configure &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.lv.controller")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("小宝贝？摸摸捶？") .description("Spring Boot + Swagger2") .termsOfServiceUrl("https://blog.csdn.net/weixin_41368010") .contact("lv") .version("1.0") .build(); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一次用python爬取数据，了解基本构架思想]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F03%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8python%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%9E%B6%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[——准备工作11.官网下载python2.7; 12.配置python环境变量 13.在eclipse 的 marketplace中下载安装相关环境IDE; 124.在PyDev的Interpreters中配置 Python Interpreters :1）点击 new 添加 python.exe的路径 ，点击Apply 二创建python工程创建如下几个module123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164 1. html_download(下载html)# coding: UTF-8 import urllib2 class HtmlDownloader(object): def download(self, url): if url is None: return None response = urllib2.urlopen(url) if response.getcode() != 200: return None return response.read()2. html_parser(解析html)# coding: UTF-8 import re from bs4 import BeautifulSoup import urlparse class HtmlParser(object): def _get_new_urls(self, page_url, soup): new_urls = set() links =soup.find_all('a', href=re.compile(r"/item/")) for link in links: new_url=link['href'] new_full_url =urlparse.urljoin(page_url,new_url) new_urls.add(new_full_url) return new_urls def _get_new_data(self, page_url, soup): res_data = &#123;&#125; # &lt;dd class="lemmaWgt-lemmaTitle-title"&gt;&lt;h1&gt;Python&lt;/h1&gt; #url res_data['url'] = page_url title_node =soup.find('dd',class_="lemmaWgt-lemmaTitle-title").find("h1") res_data['title'] = title_node.get_text() summary_node = soup.find('div', class_='lemma-summary') res_data['summary'] = summary_node.get_text() return res_data def parse(self,page_url,html_cont): if page_url is None or html_cont is None: return soup = BeautifulSoup(html_cont,'html.parser',from_encoding='utf-8') new_urls=self._get_new_urls(page_url,soup) new_data=self._get_new_data(page_url,soup) return new_urls,new_data 3. spider_main(调度程序)# coding: UTF-8 import url_manager, html_downloader, html_parser,html_outputer class SpiderMain(object): def __init__(self): self.urls =url_manager.UrlManager() self.downloader=html_downloader.HtmlDownloader() self.parser=html_parser.HtmlParser() self.outputer=html_outputer.HtmlOutput() def craw(self,root_url): count=1 self.urls.add_new_url(root_url) while self.urls.has_new_url(): try: new_url=self.urls.get_new_url() print 'craw %d : %s '%(count,new_url) html_cont=self.downloader.download(new_url) new_urls,new_data=self.parser.parse(new_url,html_cont) self.urls.add_new_urls(new_urls) self.outputer.collect_data(new_data) if count==10: break count=count+1 except: ('craw failed') self.outputer.output_html() if __name__=="__main__": root_url = 'https://baike.baidu.com/item/Python' obj_spider=SpiderMain() obj_spider.craw(root_url) 4. url_manager(管理url地址)# coding: UTF-8 class UrlManager(object): def __init__(self): self.new_urls=set() self.old_urls=set() def add_new_url(self,url): if url is None: return if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) def add_new_urls(self,urls): if urls is None or len(urls)==0: return for url in urls: self.add_new_url(url) def has_new_url(self): return len(self.new_urls) !=0 def get_new_url(self): new_url=self.new_urls.pop() self.old_urls.add(new_url) return new_url5. html_output(输出解析出来的数据,并展示在页面)# coding: UTF-8 class HtmlOutput(object): def __init__(self): self.datas = [] def collect_data(self, data): if data is None: return self.datas.append(data) def output_html(self): fout = open('output.html', 'w') fout.write("&lt;html&gt;") fout.write("&lt;head&gt;&lt;meta http-equiv='content-type' content='text/html;charset=utf-8'&gt;&lt;/head&gt;") fout.write("&lt;body&gt;") fout.write("&lt;table&gt;") if len(self.datas) == 0: print "kong " for data in self.datas: fout.write("&lt;tr&gt;") fout.write("&lt;td&gt;%s&lt;/td&gt;" % data['url']) # 默认为ascii，所以要在后面修改为utf8 fout.write("&lt;td&gt;%s&lt;/td&gt;" % data['title'].encode('utf8')) fout.write("&lt;td&gt;%s&lt;/td&gt;" % data['summary'].encode('utf8')) fout.write("&lt;/tr&gt;") fout.write("&lt;/table&gt;") fout.write("&lt;/body&gt;") fout.write("&lt;/html&gt;") fout.close() output.xml(运行完程序自动生成的)]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring+hibernate逆向生成数据表]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F03%2Fspring-hibernate%E9%80%86%E5%90%91%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1：配置.cfg.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; ## 2:配置外部资源db.properties``` bash jdbc.user=root jdbc.password=123456 jdbc.driverClass=com.mysql.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql:///spring3 jdbc.initPoolSize=5 jdbc.maxPoolSize=10``` ## 3:创建实体类以及 .hbm.xml(映射文件)## 4：配置spring配置文件（applicationContext.xml） ``` bash &lt;bean&gt; &lt;context:component-scan base-package="com.lv.spring.hibernate"&gt;&lt;/context:component-scan&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置spring的sessionFactor实例 :通过spring提供的LocalSessionFactoryBean配置 --&gt; &lt;bean id="SessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;!--配置数据源属性 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--配置hibernate的位置及名称 --&gt; &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;!--配置hibernate映射文件的位置及名称 --&gt; &lt;property name="mappingLocations" value="com/lv/spring/hibernate/entities/*.hbm.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 5:测试123456789101112131415161718public class SpringHibernateTest &#123; private ApplicationContext act = null; &#123; act = new ClassPathXmlApplicationContext("applicationContext.xml"); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = act.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[初学SpringBoot注释，controller，一些深坑]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F27%2F%E5%88%9D%E5%AD%A6SpringBoot%E6%B3%A8%E9%87%8A%EF%BC%8Ccontroller%EF%BC%8C%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Error:SpringBoot Configuratiob Annotation Process or not founf in classPath.解决方法：添加pom的spring依赖—&gt; &lt;dependency&gt;# &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; 注解：1:@RestController=@Controller+@RespobseBody 2:通过集合的方式被不同的前缀（如：hello、hi都可以访问相同的方法）访问@RequestMapping(value = {"/hello","/hi"} ,method = RequestMethod.GET) Controller的使用@PathVariable //@RequestMapping(value ="/say/{id}" ,method = RequestMethod.GET) //void say(@PathVariable("id") Integer id){ // return "id:"+id} @RequestParam 获取请求参数的值 //(@RequestParam(value="id" ,required = false,defaultValue = "0") @GetMapping 组合注解 //@RequestMapping(value ="/say" ,method = RequestMethod.GET) //@GetMapping(value ="/say")]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单了解AOP,以及spring整合hibernate]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F23%2F%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3AOP-%E4%BB%A5%E5%8F%8Aspring%E6%95%B4%E5%90%88hibernate%2F</url>
    <content type="text"><![CDATA[## ----注解的方式配置bean; IOC容器就是具有依赖注入功能的容器, IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 ## ----AOP 基于注解的方式 1,可以通过order安排优先级; 2,使用pointcut来声明切入表达式; 3,其它的通知直接使用方法名来引用当前的切入点（如：@before ，@after等等） ## ----了解了spring整合hibernate： 主要是spring的xml文件的配置； 一:配置数据源 &lt;context:property-placeholder location=”classpath:db.properties” /&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;${jdbc.initPoolSize}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${jdbc.maxPoolSize}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 二:配置spring的SessionFactory的实例：通过spring提供的LocalSessionFactoryBean配置;&lt;bean id=&quot;SessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt; #### &lt;!--配置数据源属性 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; #### &lt;!--配置hibernate的位置及名称 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;&gt;&lt;/property&gt; #### &lt;!--配置hibernate映射文件的位置及名称 --&gt; &lt;property name=&quot;mappingLocations&quot; value=&quot;com/lv/spring/hibernate/entities/*.hbm.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 三:配置spring的声明式事务#### &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;SessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; #### &lt;!-- 配置事务属性，需要事务管理器 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; #### &lt;!-- 配置事务切点，并把事务切点和事务属性关联起来 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.lv.spring.hibernate.*.*(..))&quot; id=&quot;txPointcut&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot; /&gt; &lt;/aop:config&gt; ##（其中第一步的导入资源文件为：db.properties文件） jdbc.user=root jdbc.password=123456 jdbc.driverClass=com.mysql.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql:///spring1 jdbc.initPoolSize=5 jdbc.maxPoolSize=10]]></content>
  </entry>
  <entry>
    <title><![CDATA[配置bean作用域，生命周期，以及Spring通过工厂方法配置bean]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F16%2F%E9%85%8D%E7%BD%AEbean%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E4%BB%A5%E5%8F%8ASpring%E9%80%9A%E8%BF%87%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AEbean%2F</url>
    <content type="text"><![CDATA[–使用bean的scope 属性来配置bean的作用域12singleton：默认值，容器初始化是创建bean实例，在整个容器生命周期内只创建一次bean，单例。prototype：原型的。容器初始化时不创建bean实例，而在每次请求时都创建一个新的bean，并返回。 –IOC容器中Bean 的生命周期1234567891011Spring允许在Bean生命周期的特定点执行定制任务Spring IOC容器对Bean的生命周期管理过程：1&gt;&gt;通过构造器或工厂方法创建Bean实例2&gt;&gt;为Bean的属性设置值和对其他Bean的引用3&gt;&gt;调用Bean的初始化方法4&gt;&gt;可以开始使用Bean5&gt;&gt;当容器关闭时，调用Bean的销毁方法Bean：init-method（初始化）和destory-method（销毁）; –配置Bean的后置处理器：不需要配置id ，IOC容器自动识别是一个BeanPostProcessor接口;–Spring_通过工厂方法配置bean12345678--通过静态工厂方法配置bean class:指向静态工厂方法的全类名; factory-method: 指向静态工厂方法名; constructor-arg；使用constructor传参并配置;--通过实例工厂方法配置bean factory-bean:指向实例工厂中的bean; factory-method: 指向静态工厂方法名; constructor-arg；使用constructor传参并配置;]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring-自动装配以及注入方式]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F16%2Fspring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%BB%A5%E5%8F%8A%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[$ Spring注入方式： 1；设置注入(属性注入) ，有一个set xx的方法 2: 构造注入(构造器注入) ，有一个构造器 $ spring自动装配 其中的age , name, car-ref(都是引用) Spring IOC容器自动配置Bean 在 的autowirs属性里指定自动装配的模式例如：1：byType(根据类型自动装配)：不可取，如果多个类型相同的bean,Spring无法判断 2：byName(根据名称自动配置)：必须将Bean 的名称和属性名设置的完全相同。 3：constructor(构造器自动配置)：不可取，如果 bean 中存在多个构造器，会很复杂。 &lt;bean:xml里面的··· 当前bean指xml外的容器里的属性&gt;autowirs 属性指定自动装配1：byName 根据bean 名字 和当前 bean 的setter 风格属性名进行配置，if 没有找到则null;2: byType 根据bean 类型 和当前bean的属性自动装配，if IOC容器里有一个以上相同的bean，则抛异常。缺点：必须都是用要么byName要么byTtpe。（一般很少在实际项目中使用） spring 配置继承1；（parent操作）2；abstract：抽象的bean不能实例化，只能xml中被其他bean被继承]]></content>
  </entry>
  <entry>
    <title><![CDATA[stupid-pig]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F14%2Fstupid-pig%2F</url>
    <content type="text"><![CDATA[I’m a stupid pig after drinking artificial wine.This is my first hexo and blog~ i think it’s tremendous low. So now, i’m learning css. learn togetherIf u want learn with me. u can point here! 1$ I'm lvtian . Please remember me!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
