<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[两种多线程实现方式的区别(Thread和Runnable)]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F17%2F%E4%B8%A4%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB-Thread%E5%92%8CRunnable%2F</url>
    <content type="text"><![CDATA[两种多线程实现方式的区别(Thread和Runnable)1,Thread类是Runnable接口的子类;Runnable接口解决了Thread单继承的短板； 多个对象访问同一资源，通过Runnable实现 2,Runnable接口实现的多线程更加清楚的描述了数据共享的概念Thread单继承(三个任务给了三个线程)12345678910public class TheadTest &#123; public static void main(String[] args) &#123; TheadDemo mt1= new TheadDemo("一号窗口"); TheadDemo mt2= new TheadDemo("二号窗口"); TheadDemo mt3= new TheadDemo("三号窗口"); mt1.start(); mt2.start(); mt3.start();&#125;&#125; Runnable数据共享(一个任务给了三个线程)1234567891011public class RunableTest &#123; public static void main(String[] args) &#123; RunableDemo mt = new RunableDemo(); Thread t1 = new Thread(mt,"一号窗口"); Thread t2 = new Thread(mt,"二号窗口"); Thread t3 = new Thread(mt,"三号窗口"); t1.start(); t2.start(); t3.start();&#125;&#125; 举例说明继承Thread类的，相当于三个卖票10张的任务分别分给三个窗口，他们各做各的事各卖各的票各完成各的任务，因为MyThread继承Thread类，所以在new MyThread的时候在创建三个对象的同时创建了三个线程；实现RUNNABLE的，相当于是拿出一个卖票10张得任务给三个人去共同完成，new MyThread相当于创建一个任务，然后实例化三个Thread，创建三个线程即安排三个窗口去执行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java线程实现的三种方式以及概念]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F17%2Fjava%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[java线程是通过java.lang.Thread类来实现的。VM启动时会有一个由主方法(public static void main(){})所定义的线程;可以通过Thread的实例来创建新的线程;每个线程都是通过某个特定的Thread对象所对应的run()方法来完成其操作,方法run()成为线程体;通过Thread类的start()方法来启动一个线程;java线程实现的三种方式继承Thread类12345678910111213141516171819202122232425public class Runnable &#123; public static void main(String[] args) &#123; Run r1=new Run("lll"); Run r2=new Run("mmm"); Run r3=new Run("ppp"); r1.start(); r2.start(); r3.start(); &#125; &#125;class Run extends Thread&#123; private String name; public Run(String name)&#123; this.name=name; &#125; @Override public void run() &#123; for(int x=0;x&lt;100;x++)&#123; System.out.println("x:"+x+"name"+this.name); &#125; &#125;&#125; 发现：123456781,在执行此代码的时候，如果没有变化是因为CUP运行快;2,Thread源码里面有个IllegalThreadStateException异常，属于选择性处理异常， 当线程重复启动就会报这个错;3,其中的start0()方法结构类似于java中的抽象方法,使用native声明，会使用到JNI技术: 使用java调用本身操作系统提供的函数; 在不同的操作系统中JVM提供了实现start0()方式;4,通过Thread类的start()方法不仅仅要启动多线程的执行代码,而且根据不同的操作系统完成资源分配;5,多进程会抢占资源，所以不可能一个执行完后，执行另一个; public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } private native void start0(); 通过实现Runnable接口来实现多线程实现Runable接口并没有start()方法,但是在Thread类中定义了public Thread(Runnable target)方法, 接收的是Runnable接口对象 public class Runnable { public static void main(String[] args) { Run r1=new Run("lll"); Run r2=new Run("mmm"); Run r3=new Run("ppp"); new Thread(r1).start();//匿名对象 new Thread(r2).start(); new Thread(r3).start(); } } class Run implements java.lang.Runnable { private String name; public Run(String name){ this.name=name; } @Override public void run() { for(int x=0;x&lt;100;x++){ System.out.println("x:"+x+"name"+this.name); } } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[引用传递,数据表与简单java类的映射]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F16%2F%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92-%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%B8%8E%E7%AE%80%E5%8D%95java%E7%B1%BB%E7%9A%84%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[引用传递：同一块堆内存空间可以被不同的桟内存所指向，同一桟内存可以对不同的堆内存进行修改;12345678910111213141516171819202122232425class Message&#123; private String num="nihao"; public Message(String num)&#123; this.num=num; &#125; public String getNum() &#123; return num; &#125; public void setNum(String num) &#123; this.num = num; &#125;&#125;public class reference &#123; public static void main(String[] args) &#123; Message msg= new Message("hello"); fun(msg);//引用传递 System.out.println(msg.getNum()); &#125; public static void fun(Message temp)&#123; temp.setNum("world"); &#125;&#125; 数据表与简单java类的映射一,实现基本字段转换二,设置并取出数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 class Emp&#123; private int Eid; private String Ename; private Dep dep;//设置外键，一个雇员属于多个部门 private Emp mrg;//一个员工对应的领导； public void setMrg(Emp mrg)&#123; this.mrg=mrg; &#125; public Emp getMrg()&#123; return this.mrg; &#125; public void setDep(Dep dep)&#123; this.dep=dep; &#125; public Dep getDep()&#123; return this.dep; &#125; public Emp(int id ,String Ename)&#123; this.Eid=id; this.Ename=Ename; &#125; public String info()&#123; return "员工编号"+this.Eid+"员工名"+this.Ename; &#125;&#125;class Dep&#123; private int Did; private String Dname; private Emp emps[];//设置外键,一个部门有多个员工 public void setEmps(Emp[] emps)&#123; this.emps=emps; &#125; public Emp[] getEmps()&#123; return this.emps; &#125; public Dep(int Did,String Dname)&#123; this.Did=Did; this.Dname=Dname; &#125; public String info()&#123; return "员工编号"+this.Did+"部门名"+this.Dname; &#125;&#125;public class Mapping &#123; public static void main(String[] args) &#123; /*1,产生各自独立对象*/ Dep dep=new Dep(1,"lll"); Emp ea=new Emp(01,"mmm"); Emp eb=new Emp(02,"nnn"); Emp ec=new Emp(03,"bbb"); /* 2,设置雇员和领导关系*/ ea.setMrg(eb); eb.setMrg(ec); /* 3,设置雇员和部门关系*/ ea.setDep(dep); eb.setDep(dep); ec.setDep(dep); dep.setEmps(new Emp[]&#123;ea,eb,ec&#125;); /* 通过员工找到部门和领导信息*/ System.out.println(ea.getDep().info()); System.out.println(eb.getDep().info()); System.out.println(ec.getDep().info()); System.out.println(eb.getMrg().info()); System.out.println(ea.getMrg().info()); System.out.println("---------------"); /* 通过部门找到每个雇员以及领导的信息*/ System.out.println(dep.info()); for(int x=0;x&lt;dep.getEmps().length;x++)&#123; System.out.println(dep.getEmps()[x].info()); /* System.out.println(dep.getEmps()[x].getMrg().info());*/ if(dep.getEmps()[x].getMrg()!=null)&#123; System.out.println(dep.getEmps()[x].getMrg().info()); &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[对象数组]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F14%2F%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[对象数组(将多个对象统一交给数组管理)定义对象数组动态初始化声明并开辟对象数组：类名称 对象数组名称 [] =new 类名称[长度];分步完成：####### 声明对象数组 ######## 开辟对象数组1234567891011121314151617181920212223242526272829303132333435363738class ArrayDemo&#123; private String id; private double price; public ArrayDemo(String i, double p)&#123; id=i; price=p; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public String info()&#123; return "id:"+id+"price:"+price; &#125;&#125;public class ObjectArr &#123; public static void main(String[] args) &#123; ArrayDemo oa[] = new ArrayDemo[3]; oa[0] = new ArrayDemo("1", 1.0); oa[1] = new ArrayDemo("2", 2.0); oa[2] = new ArrayDemo("3", 3.0); for (int x = 0; x &lt; oa.length; x++) &#123; System.out.println(oa[x].info()); &#125; &#125;&#125; 静态初始化：类名称 对象数组名称[] =new 类名称[]{实例化对象,实例化对象,…}123456789101112131415161718192021222324252627282930313233343536373839class ArrayDemo&#123; private String id; private double price; public ArrayDemo(String i, double p)&#123; id=i; price=p; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public String info()&#123; return "id:"+id+"price:"+price; &#125;&#125;public class ObjectArr &#123; public static void main(String[] args) &#123; ArrayDemo oa[] = new ArrayDemo[]&#123; new ArrayDemo("1", 1.0), new ArrayDemo("2", 2.0), new ArrayDemo("3", 3.0)&#125;; for (int x = 0; x &lt; oa.length; x++) &#123; System.out.println(oa[x].info()); &#125; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组的排序和拷贝]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F14%2F%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[升序排列123456789101112131415161718192021222324public class Sort &#123; public static void main(String[] args) &#123; int date []=new int []&#123;1,3,2,6,5,8,4,9,7&#125;; Ssort(date); print(date); &#125; public static void Ssort(int arr[])&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr.length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int pl=arr[j]; arr[j]=arr[j+1]; arr[j+1]=pl; &#125; &#125; &#125; &#125; public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125; 前后转置(一维数组)1234567891011121314151617181920212223242526272829public class ChangTwo &#123; public static void main(String[] args) &#123; int date[]=new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; sort(date); print(date); &#125; public static void sort(int arr[])&#123; int len=arr.length/2; int head=0; int foot=arr.length-1; for(int x=0;x&lt;len;x++)&#123; int temp=arr[head]; arr[head]=arr[foot]; arr[foot]=temp; head++; foot--; &#125; &#125; public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125; 数组的操作方法数组的拷贝：将一个数组的部分内容拷贝到另一个数组当中;12345678910111213141516public class ArrayCopy &#123; public static void main(String[] args) &#123; int dateA[]=new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; int dateB[]=new int[]&#123;11,12,13,14,15,46,17,18,19&#125;; System.arraycopy(dateA,4,dateB,4,3);//(源数组,开始索引，目标数组，开始索引，索引长度),拷贝并替换; print(dateB); &#125; public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125; 数组排序12345678910111213141516171819202122232425public class Sort &#123; public static void main(String[] args) &#123; int date []=new int []&#123;1,3,2,6,5,8,4,9,7&#125;; /*Ssort(date);*/ Arrays.sort(date); print(date); &#125; /*public static void Ssort(int arr[])&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr.length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int pl=arr[j]; arr[j]=arr[j+1]; arr[j+1]=pl; &#125; &#125; &#125; &#125;*/ public static void print(int temp[])&#123; for(int x=0;x&lt;temp.length;x++)&#123; System.out.print(temp[x]+" "); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[封装型,构造函数,以及匿名对象的使用]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F13%2F%E5%B0%81%E8%A3%85%E5%9E%8B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E4%BB%A5%E5%8F%8A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一:封装性1,所有类当中定义的属性都必须使用private声明，如果被外部类引用，定义相应的setter,getter方法；2，封装性就是类内部定义的属性对外部不可见;二:构造方法的基本语法及调用时机1,构造方法：类名与方法名相同，无返回值声明;2,构造方式实在类对象被实例化(new)之后默认被调用的;3,一个类中至少保留一个构造方法;4,构造方式是在对象被实例化之后：只能调用一次; 普通方法是在对象被实例化之后：多次调用;（说白了就是构造方法的重载）1234567891011121314151617181920212223242526272829303132333435363738394041424344### 5,构造方法的核心作用:在类对象实例化的时候，设置属性的初始化内容; User user =new User();//类对象实例化 public User(String name;String age)&#123; this.name=name; this.age=age; &#125;//设置属性的初始化内容public class Structure &#123; public static void main(String[] args) &#123; Boook bk= null; bk = new Boook();//构造方法只有在声明并实例化之后，才会被引用；22 System.out.println(bk);//成为垃圾了(内存) bk=new Boook();//bk改变成为新的引用，之前的22成为垃圾(内存) System.out.println(bk); bk.info();//多次调用 bk.info(); bk.info(); &#125;&#125;class Boook&#123; private String id; private double price; public void info()&#123; System.out.println("********")&#125; public Boook()&#123; System.out.println(".........."); &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125;&#125; 6,匿名对象在重载时，要求至改变参数的类型和个数;三:匿名对象的基本使用123456781，匿名对象由于没有其它对象对其进行引用，所以只能使用一次，然后成为垃圾(内存)； public static void main(String[] args) &#123; /*Book bk = new Book("hello",1.0); bk.info();*/ new Book("hello",1.0).info();//匿名对象的使用,且无法被引用。 &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[递归，类和对象，堆内存和桟内存]]></title>
    <url>lvtian123.github.io%2F2018%2F07%2F12%2F%E9%80%92%E5%BD%92%EF%BC%8C%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A1%9F%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[一:递归12345678910111213141516171,递归必须发生在方法中;2,递归必须有规定条件，不然就像耕地一样，耕死了。例子：public class recursive &#123; public static void main(String[] args) &#123; System.out.println(sum(100)); System.out.println(sum(200)); &#125; public static int sum(int num)&#123; if(num==1)&#123; return 1; &#125; return num+sum(num-1); &#125;&#125; 二:类与对象12345678910111,类与对象是整个面向对象之中最为基础的组成元素,(类是共性的集合，对象是某个性的产物。)2,类是描述对象的结构想要使用类必须要有对象，对象的定义方式：1：声明并实例化：User user = new User(); 2: 分步完成：User user=null; user=new User();引用数据类型与基本数据类型的不同在于需要的内存的开辟及使用，所以new的主要功能就是开辟内存空间； 首字母大写的都是类名称，类名称都是引用类型，应用类型的默认值都是空; 三:堆内存和桟内存123456789堆内存：只有在new一个对象的时候，才会开辟一个堆内存（实例化对象）桟内存：存放堆内存的地址(一个桟内存只能指定一个堆内存，一个堆内存可以被多个桟内存指定)产生的垃圾会被垃圾收集器CG回收引用传递: Book b=null; Book a=new Book(); a.id="1"; a.price=2.0; b=a;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Our love is too helpless]]></title>
    <url>lvtian123.github.io%2F2018%2F06%2F13%2FOur-love-is-too-helpless%2F</url>
    <content type="text"><![CDATA[Yes,i’m during a Phase transformation,Before two days, i break up with my girlfriends who get along with me about three years,Here i will review some experience about three years,it’s realized a conclusion for me,----------------------2015.9.13------------------- this day, i enter a university what be expected by family,everthing is just beginning,andtry New things. So, i join the Student union where to give me love,we know each other in there.i deeply love this girl where in front of my eyes,i beginning chat with her until midnight,she enjoyed.So,i think it’s a good time that i can make an appointment ,We met on theporch bridge behind the school. We talked about our ideal life and the university.In the first place. When I asked her if she was thinking about dating in college, sherefused.And I don’t give up, on my offensive.She gradually recognized me and gave me a two-week test period, which was actuallyonly one week. ---------------------2015.10.11------------------- This day I want to kiss her, by her clever dodge away, the old face dark red, angryand ashamed of me in the space to say disdain oneself ---------------------2018.6.11-------------------- That day, at the end of our junior year, we ended up arguing.On second thought, in this relationship, we all pay a lot and love each other deeply.We try to accommodate each other, but,The quarrel has never let the fire out, so I choseto give up, although I still love deeply, but at this time a kind of torture to the soul.only Letting each other go? Love is for mutual comfort. After that, I only remember that there was a quarrel. Yes, there was an endless quarrel. Please cherish each other’s feelings]]></content>
  </entry>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>lvtian123.github.io%2F2018%2F06%2F05%2F%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[CREATE TABLE tea (tid INT ( 10 ) NOT NULL PRIMARY KEY AUTO_INCREMENT,tname VARCHAR(20),tphonum VARCHAR(20)) CREATE TABLE course(cid int (20) not null PRIMARY KEY auto_increment,cname VARCHAR(20) not null) CREATE TABLE xuanke( sid int (10),tid int (10),cid int (10),xuefen int (20) ) SELECT * FROM tea; 1-- 使用on 句子 SELECT s.sname,t.tname,c.cname,x.xuefen from stu s join xuanke x on s.sid = x.sid join tea t on t.tid = x.tid join course c on c.cid = x.cid ; 1-- 使用using句子 SELECT s.sname,t.tname,c.cname,x.xuefen from stu s join xuanke x using(sid) join tea t using(tid) join course c using(cid) ; 1-- left/right join 以及过滤条件 where ,and SELECT s.sname , x.xuefen FROM stu s right join xuanke x using(sid) where sname=”ll”; 1-- 笛卡尔积 select * from stu,tea,course,xuanke; select * from stu CROSS JOIN tea;]]></content>
  </entry>
  <entry>
    <title><![CDATA[shiro安全以及md5加密学习]]></title>
    <url>lvtian123.github.io%2F2018%2F06%2F01%2Fshiro%E5%AE%89%E5%85%A8%E4%BB%A5%E5%8F%8Amd5%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1## 2018.5.31 学习shiro– shiro session管理– shiro 缓存管理– shiro 集成Spring 什么是shiro–Apache的强大灵活开源安全框架 –认证，授权，企业会话管理，安全加密 shiro与sping securityshiro : 简单，灵活， 可脱离spring 粒度较粗 sping security ： 复杂，笨重 不可脱离spring 粒度较细(粒度：个人认为就是管理事务的程度，每条河如果是粒度较细，汇聚成大海，那么大海就是粒度较粗) shrio整体架构：Authenticator: 认证器（管理登录和退出）---&gt;通过Realms获取认证信息 ，做对比 Authorizer: 授权器 （subject有哪些权限）---&gt;通过Realms获取认证信息 ，做对比 Session Manager Session Dao Cache Manager(缓存管理器) Pluggable Realms数据库，数据源之间的桥梁 Cryptography:加密 Shiro认证创建SecurityManager–&gt;主体提交认证（Subject）–&gt;SecurityManager认证–&gt;Authenticator认证–&gt;Realm验证 Shiro自定义Realm 以及 自定义RealmIniRealm jdbcRealm ；设置权限数据默认为false; jdbcRealm.setPermissionsLookupEnabled(true); 1## 2018.6.1 Shiro加密shiro散列配置 : HashedCredentialsMatcher 自定义Realm中使用散列 盐的使用 （使用md5加密） 学习redis nosql 数据存储的瓶颈1.数据量的总大小，一个机器放不下时2.数据的索引（b+tree）一个机器的内存放不下时3.访问量（读写混合）一个实例不能承受 Memcached缓存缓解数据库压力]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单的ssm框架设计]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F30%2F%E7%AE%80%E5%8D%95%E7%9A%84ssm%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1## 2018.5.20 1；ssm2; mysql3; bootstrap4; maven5; 分页pagehelper6; 逆向工程 Mybatis Generator 环境搭建1；maven2；bootstrap 1## 2018.5.29 springBoot底层使用slf4j+logback的方式进行日志记录 1## 2018.5.30 模版引擎：thymeleaf]]></content>
  </entry>
  <entry>
    <title><![CDATA[123]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F09%2F123%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[第一次使用idea，用maven管理springboot+swagger集成，实现对数据库(mysql)的CRUD]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F04%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8idea%EF%BC%8C%E7%94%A8maven%E7%AE%A1%E7%90%86springboot-swagger%E9%9B%86%E6%88%90%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93-mysql-%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[一；创建maven管理的springboot工程（此步骤忽略）二：配置pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;SpringBootLearning&lt;/groupId&gt; &lt;artifactId&gt;SpringBootLearning&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--添加swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Mysql和JPA--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 三：配置application.properties(此处为我的数据库)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 server.port=8080 spring.datasource.url = jdbc:mysql://localhost:3306/people spring.datasource.username = root spring.datasource.password = 123456 spring.datasource.driverClassName = com.mysql.jdbc.Driver # Specify the DBMS spring.jpa.database = MYSQL # Show or not log for each sql query spring.jpa.show-sql = true # Hibernate ddl auto (create, create-drop, update) spring.jpa.hibernate.ddl-auto = update``` ## 四：java层面（bean,dao,controller）以及同等级的Swagger2Configure### 1；bean``` bash package com.lv.bean; import javax.persistence.*; @Entity @Table(name = "user") public class User &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private int age; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 2.Dao123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163 package com.lv.dao; import com.lv.bean.User; import org.springframework.data.repository.CrudRepository; public interface UserDao extends CrudRepository&lt;User, Long&gt; &#123; public User findById(Long id); public User findByName(String name); &#125; （为什么我只写了两个方法呢？因为CrudRepository已经包含了我们所需要的其它方法） ``` ### 3.controller``` bash package com.lv.controller; import com.lv.dao.UserDao; import com.lv.bean.User; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController @RequestMapping(value = "/user") @Api(description = "UserController") public class UserController &#123; @Resource UserDao userDAO; @ApiOperation(value = "添加用户") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "name" , value = "name" , paramType = "query" , required = true ), @ApiImplicitParam(name = "age" , value = "age" , paramType = "query" , required = true ) &#125;) @RequestMapping(value = "/addUser" , method = RequestMethod.POST) public String addUser(@RequestParam(value = "name") String name,@RequestParam(value = "age") int age)&#123; User user = new User(); user.setName(name); user.setAge(age); userDAO.save(user); return "add user success !"; &#125; @ApiOperation(value="按姓名查找") @ApiImplicitParam(name = "name",value = "name", paramType = "query",required = true,dataType = "string") @RequestMapping(value ="/findByName",method = RequestMethod.POST) public String findByName(@RequestParam(value= "name") String name)&#123; User user =userDAO.findByName(name); if(user == null)&#123; return "error"; &#125;else&#123; return "id:"+user.getId()+",name:" + user.getName() + " , age:" + user.getAge(); &#125; &#125; @ApiOperation(value = "查找用户") @ApiImplicitParam(name = "id" , value = "id" , paramType = "query" , required = true , dataType = "int") @RequestMapping(value = "/findById" , method = RequestMethod.POST) public String findById(@RequestParam(value = "id") Long id)&#123; User user = userDAO.findById(id); if(user == null)&#123; return "error"; &#125;else&#123; return "name:" + user.getName() + " , age:" + user.getAge(); &#125; &#125; @ApiOperation(value = "查询所有用户") @RequestMapping(value = "/findAll" , method = RequestMethod.POST) public Iterable findAll()&#123; Iterable&lt;User&gt; userList = userDAO.findAll(); return userList; &#125; @ApiOperation(value ="删除所有用户") @RequestMapping(value="/deleteAll",method = RequestMethod.POST) public String deleteAll()&#123; userDAO.deleteAll(); return "delete success!"; &#125; @ApiOperation(value = "删除用户") @ApiImplicitParam(name = "id" , value = "id" , paramType = "query" , required = true , dataType = "int") @RequestMapping(value = "/deleteById" , method = RequestMethod.POST) public String deleteById(@RequestParam(value = "id") Long id)&#123; userDAO.delete(id); return "delete success !"; &#125; &#125; ``` ### 4.Swagger2Configure``` bash package com.lv; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class Swagger2Configure &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.lv.controller")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("小宝贝？摸摸捶？") .description("Spring Boot + Swagger2") .termsOfServiceUrl("https://blog.csdn.net/weixin_41368010") .contact("lv") .version("1.0") .build(); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一次用python爬取数据，了解基本构架思想]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F03%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8python%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%9E%B6%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[——准备工作11.官网下载python2.7; 12.配置python环境变量 13.在eclipse 的 marketplace中下载安装相关环境IDE; 124.在PyDev的Interpreters中配置 Python Interpreters :1）点击 new 添加 python.exe的路径 ，点击Apply 二创建python工程创建如下几个module123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164 1. html_download(下载html)# coding: UTF-8 import urllib2 class HtmlDownloader(object): def download(self, url): if url is None: return None response = urllib2.urlopen(url) if response.getcode() != 200: return None return response.read()2. html_parser(解析html)# coding: UTF-8 import re from bs4 import BeautifulSoup import urlparse class HtmlParser(object): def _get_new_urls(self, page_url, soup): new_urls = set() links =soup.find_all('a', href=re.compile(r"/item/")) for link in links: new_url=link['href'] new_full_url =urlparse.urljoin(page_url,new_url) new_urls.add(new_full_url) return new_urls def _get_new_data(self, page_url, soup): res_data = &#123;&#125; # &lt;dd class="lemmaWgt-lemmaTitle-title"&gt;&lt;h1&gt;Python&lt;/h1&gt; #url res_data['url'] = page_url title_node =soup.find('dd',class_="lemmaWgt-lemmaTitle-title").find("h1") res_data['title'] = title_node.get_text() summary_node = soup.find('div', class_='lemma-summary') res_data['summary'] = summary_node.get_text() return res_data def parse(self,page_url,html_cont): if page_url is None or html_cont is None: return soup = BeautifulSoup(html_cont,'html.parser',from_encoding='utf-8') new_urls=self._get_new_urls(page_url,soup) new_data=self._get_new_data(page_url,soup) return new_urls,new_data 3. spider_main(调度程序)# coding: UTF-8 import url_manager, html_downloader, html_parser,html_outputer class SpiderMain(object): def __init__(self): self.urls =url_manager.UrlManager() self.downloader=html_downloader.HtmlDownloader() self.parser=html_parser.HtmlParser() self.outputer=html_outputer.HtmlOutput() def craw(self,root_url): count=1 self.urls.add_new_url(root_url) while self.urls.has_new_url(): try: new_url=self.urls.get_new_url() print 'craw %d : %s '%(count,new_url) html_cont=self.downloader.download(new_url) new_urls,new_data=self.parser.parse(new_url,html_cont) self.urls.add_new_urls(new_urls) self.outputer.collect_data(new_data) if count==10: break count=count+1 except: ('craw failed') self.outputer.output_html() if __name__=="__main__": root_url = 'https://baike.baidu.com/item/Python' obj_spider=SpiderMain() obj_spider.craw(root_url) 4. url_manager(管理url地址)# coding: UTF-8 class UrlManager(object): def __init__(self): self.new_urls=set() self.old_urls=set() def add_new_url(self,url): if url is None: return if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) def add_new_urls(self,urls): if urls is None or len(urls)==0: return for url in urls: self.add_new_url(url) def has_new_url(self): return len(self.new_urls) !=0 def get_new_url(self): new_url=self.new_urls.pop() self.old_urls.add(new_url) return new_url5. html_output(输出解析出来的数据,并展示在页面)# coding: UTF-8 class HtmlOutput(object): def __init__(self): self.datas = [] def collect_data(self, data): if data is None: return self.datas.append(data) def output_html(self): fout = open('output.html', 'w') fout.write("&lt;html&gt;") fout.write("&lt;head&gt;&lt;meta http-equiv='content-type' content='text/html;charset=utf-8'&gt;&lt;/head&gt;") fout.write("&lt;body&gt;") fout.write("&lt;table&gt;") if len(self.datas) == 0: print "kong " for data in self.datas: fout.write("&lt;tr&gt;") fout.write("&lt;td&gt;%s&lt;/td&gt;" % data['url']) # 默认为ascii，所以要在后面修改为utf8 fout.write("&lt;td&gt;%s&lt;/td&gt;" % data['title'].encode('utf8')) fout.write("&lt;td&gt;%s&lt;/td&gt;" % data['summary'].encode('utf8')) fout.write("&lt;/tr&gt;") fout.write("&lt;/table&gt;") fout.write("&lt;/body&gt;") fout.write("&lt;/html&gt;") fout.close() output.xml(运行完程序自动生成的)]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring+hibernate逆向生成数据表]]></title>
    <url>lvtian123.github.io%2F2018%2F05%2F03%2Fspring-hibernate%E9%80%86%E5%90%91%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1：配置.cfg.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; ## 2:配置外部资源db.properties``` bash jdbc.user=root jdbc.password=123456 jdbc.driverClass=com.mysql.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql:///spring3 jdbc.initPoolSize=5 jdbc.maxPoolSize=10``` ## 3:创建实体类以及 .hbm.xml(映射文件)## 4：配置spring配置文件（applicationContext.xml） ``` bash &lt;bean&gt; &lt;context:component-scan base-package="com.lv.spring.hibernate"&gt;&lt;/context:component-scan&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置spring的sessionFactor实例 :通过spring提供的LocalSessionFactoryBean配置 --&gt; &lt;bean id="SessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;!--配置数据源属性 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--配置hibernate的位置及名称 --&gt; &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;!--配置hibernate映射文件的位置及名称 --&gt; &lt;property name="mappingLocations" value="com/lv/spring/hibernate/entities/*.hbm.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 5:测试123456789101112131415161718public class SpringHibernateTest &#123; private ApplicationContext act = null; &#123; act = new ClassPathXmlApplicationContext("applicationContext.xml"); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = act.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[初学SpringBoot注释，controller，一些深坑]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F27%2F%E5%88%9D%E5%AD%A6SpringBoot%E6%B3%A8%E9%87%8A%EF%BC%8Ccontroller%EF%BC%8C%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Error:SpringBoot Configuratiob Annotation Process or not founf in classPath.解决方法：添加pom的spring依赖—&gt; &lt;dependency&gt;# &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; 注解：1:@RestController=@Controller+@RespobseBody 2:通过集合的方式被不同的前缀（如：hello、hi都可以访问相同的方法）访问@RequestMapping(value = {"/hello","/hi"} ,method = RequestMethod.GET) Controller的使用@PathVariable //@RequestMapping(value ="/say/{id}" ,method = RequestMethod.GET) //void say(@PathVariable("id") Integer id){ // return "id:"+id} @RequestParam 获取请求参数的值 //(@RequestParam(value="id" ,required = false,defaultValue = "0") @GetMapping 组合注解 //@RequestMapping(value ="/say" ,method = RequestMethod.GET) //@GetMapping(value ="/say")]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单了解AOP,以及spring整合hibernate]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F23%2F%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3AOP-%E4%BB%A5%E5%8F%8Aspring%E6%95%B4%E5%90%88hibernate%2F</url>
    <content type="text"><![CDATA[## ----注解的方式配置bean; IOC容器就是具有依赖注入功能的容器, IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 ## ----AOP 基于注解的方式 1,可以通过order安排优先级; 2,使用pointcut来声明切入表达式; 3,其它的通知直接使用方法名来引用当前的切入点（如：@before ，@after等等） ## ----了解了spring整合hibernate： 主要是spring的xml文件的配置； 一:配置数据源 &lt;context:property-placeholder location=”classpath:db.properties” /&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;${jdbc.initPoolSize}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${jdbc.maxPoolSize}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 二:配置spring的SessionFactory的实例：通过spring提供的LocalSessionFactoryBean配置;&lt;bean id=&quot;SessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt; #### &lt;!--配置数据源属性 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; #### &lt;!--配置hibernate的位置及名称 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;&gt;&lt;/property&gt; #### &lt;!--配置hibernate映射文件的位置及名称 --&gt; &lt;property name=&quot;mappingLocations&quot; value=&quot;com/lv/spring/hibernate/entities/*.hbm.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 三:配置spring的声明式事务#### &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;SessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; #### &lt;!-- 配置事务属性，需要事务管理器 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; #### &lt;!-- 配置事务切点，并把事务切点和事务属性关联起来 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.lv.spring.hibernate.*.*(..))&quot; id=&quot;txPointcut&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot; /&gt; &lt;/aop:config&gt; ##（其中第一步的导入资源文件为：db.properties文件） jdbc.user=root jdbc.password=123456 jdbc.driverClass=com.mysql.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql:///spring1 jdbc.initPoolSize=5 jdbc.maxPoolSize=10]]></content>
  </entry>
  <entry>
    <title><![CDATA[配置bean作用域，生命周期，以及Spring通过工厂方法配置bean]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F16%2F%E9%85%8D%E7%BD%AEbean%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E4%BB%A5%E5%8F%8ASpring%E9%80%9A%E8%BF%87%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AEbean%2F</url>
    <content type="text"><![CDATA[–使用bean的scope 属性来配置bean的作用域12singleton：默认值，容器初始化是创建bean实例，在整个容器生命周期内只创建一次bean，单例。prototype：原型的。容器初始化时不创建bean实例，而在每次请求时都创建一个新的bean，并返回。 –IOC容器中Bean 的生命周期1234567891011Spring允许在Bean生命周期的特定点执行定制任务Spring IOC容器对Bean的生命周期管理过程：1&gt;&gt;通过构造器或工厂方法创建Bean实例2&gt;&gt;为Bean的属性设置值和对其他Bean的引用3&gt;&gt;调用Bean的初始化方法4&gt;&gt;可以开始使用Bean5&gt;&gt;当容器关闭时，调用Bean的销毁方法Bean：init-method（初始化）和destory-method（销毁）; –配置Bean的后置处理器：不需要配置id ，IOC容器自动识别是一个BeanPostProcessor接口;–Spring_通过工厂方法配置bean12345678--通过静态工厂方法配置bean class:指向静态工厂方法的全类名; factory-method: 指向静态工厂方法名; constructor-arg；使用constructor传参并配置;--通过实例工厂方法配置bean factory-bean:指向实例工厂中的bean; factory-method: 指向静态工厂方法名; constructor-arg；使用constructor传参并配置;]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring-自动装配以及注入方式]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F16%2Fspring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%BB%A5%E5%8F%8A%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[$ Spring注入方式： 1；设置注入(属性注入) ，有一个set xx的方法 2: 构造注入(构造器注入) ，有一个构造器 $ spring自动装配 其中的age , name, car-ref(都是引用) Spring IOC容器自动配置Bean 在 的autowirs属性里指定自动装配的模式例如：1：byType(根据类型自动装配)：不可取，如果多个类型相同的bean,Spring无法判断 2：byName(根据名称自动配置)：必须将Bean 的名称和属性名设置的完全相同。 3：constructor(构造器自动配置)：不可取，如果 bean 中存在多个构造器，会很复杂。 &lt;bean:xml里面的··· 当前bean指xml外的容器里的属性&gt;autowirs 属性指定自动装配1：byName 根据bean 名字 和当前 bean 的setter 风格属性名进行配置，if 没有找到则null;2: byType 根据bean 类型 和当前bean的属性自动装配，if IOC容器里有一个以上相同的bean，则抛异常。缺点：必须都是用要么byName要么byTtpe。（一般很少在实际项目中使用） spring 配置继承1；（parent操作）2；abstract：抽象的bean不能实例化，只能xml中被其他bean被继承]]></content>
  </entry>
  <entry>
    <title><![CDATA[stupid-pig]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F14%2Fstupid-pig%2F</url>
    <content type="text"><![CDATA[I’m a stupid pig after drinking artificial wine.This is my first hexo and blog~ i think it’s tremendous low. So now, i’m learning css. learn togetherIf u want learn with me. u can point here! 1$ I'm lvtian . Please remember me!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>lvtian123.github.io%2F2018%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
